\chapter{Q-Learning en acción}
\label{cap:q-learning}

En el que descubriremos un aliado en la búsqueda de la AGI, y pondremos a prueba las capacidades del Aprendizaje por Refuerzo.

\chapterquote{Si no tienes esperanza, no encontrarás lo que está más allá de tus esperanzas}{Clemente de Alejandría}

\section{OpenAI}
OpenAI es una iniciativa cuyo objetivo es asegurar que la \textbf{Inteligencia Artificial General} (AGI) beneficie a toda la humanidad. En su web (\citet{OpenAI_charter}) se encuentra el siguiente manifiesto:

\begin{quote}
    La misión de OpenAI es asegurar que la inteligencia artificial general - refiriéndose a sistemas altamente autónomos que superen el rendimiento humano en el trabajo más valioso económicamente - beneficie a toda la humanidad. Intentaremos desarrollar AGI de una forma segura y beneficiosa, pero también consideraremos nuestra misión completa si nuestro trabajo ayuda a otros a conseguir esta meta. 
\end{quote}

En busca de este objetivo, OpenAI sigue tres caminos:
\begin{itemize}
    \item \textbf{Investigación y desarrollo:} Sus contribuciones al Aprendizaje Automático como estado del arte durante los últimos años no han sido pocas: desde nuevos algoritmos de Aprendizaje por Refuerzo (\citet{baselines}) hasta demostraciones de cómo una Inteligencia Artificial puede sobrepasar a jugadores expertos (\citet{OpenAI_dota}).
    \item \textbf{Recursos académicos} puestos a disposición por \citet{spinningup} para todo aquél que quiera aprender sobre el Aprendizaje por Refuerzo Profundo.
    \item \textbf{Herramientas y plataformas} mediante las cuales facilitar la labor de investigación y pruebas del Aprendizaje Automático.
\end{itemize}

Es nuestra investigación nos serviremos de una de estas plataformas, \textbf{OpenAI Gym}, para experimentar y descubrir los puntos fuertes y débiles de las distintas técnicas y algoritmos de aprendizaje. 

Gym es un conjunto de herramientas para desarrollar y comparar algoritmos de aprendizaje de refuerzo. En él los agentes son capaces de aprender cualquier cosa, desde caminar hasta jugar a juegos como Pong o Pinball.

Para ello la librería aporta al usuario una interfaz sencilla, a través de la cual se le provee un entorno de simulación. En nuestro caso, el algoritmo que proporcionaremos será el agente que interaccionará con el entorno para aprender de él e intentar lograr unos objetivos.

\section{CartPole}
\begin{quote}
    Un mástil está unido por una bisagra a un carro, el cual se mueve a lo largo de una pista sin rozamiento. El sistema es controlado aplicando una fuerza de +1 o -1 al carro. El péndulo (mástil) comienza en posición vertical, el objetivo es prevenir que caiga. Una recompensa de +1 es otorgada por cada \textit{timestep} que el mástil permanece erguido. El episodio finaliza cuando el mástil se encuentra desplazado más de 15 grados de su posición vertical, o el carro se mueve más de 2.4 unidades del centro.
\end{quote}

Este es el enunciado del primer problema que resolveremos mediante técnicas de Aprendizaje por Refuerzo. La implementación del problema nos viene dada como parte de la librería \textit{OpenAI Gym}. Una vez importado el problema, dispondremos de un entorno con el que interactuar y nuestro objetivo será crear un agente que interaccione con el mismo.

Nuestro conjunto de acciones, como se indica en el enunciado, tiene dos elementos: Aplicar fuerza hacia la derecha o aplicar fuerza hacia la izquierda. El agente deberá decidir cuál de estas dos acciones tomar y se lo comunicará al entorno. Éste responderá con cuatro elementos:

\begin{itemize}
    \item \textbf{Observación} (objeto): Consiste en un array que contiene la información necesaria para describir el estado actual (tras aplicar la última acción). Los valores posibles pueden verse en la tabla \ref{obs-cartpole}.
    \item \textbf{Recompensa} (float): Refuerzo para el agente, +1.0 mientras la simulación continúe.
    \item \textbf{Fin} (boolean): Señal que indica si la simulación ha concluido, bien porque el mástil ha caído o porque lo hemos mantenido en pie durante el tiempo suficiente.
    \item \textbf{Info} (diccionario): Información de diagnóstico útil para la depuración del agente. No obstante, esta información no debe ser usada por el agente para aprender.
\end{itemize}
\begin{table}[]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    \textbf{Num} & \textbf{Observación} & \textbf{Min} & \textbf{Max} \\ \hline
    0            & Posición del carro   & -4.8         & 4.8          \\ \hline
    1            & Velocidad del carro  & -Inf         & Inf          \\ \hline
    2            & Ángulo del poste     & -24º         & 24º          \\ \hline
    3            & Velocidad del poste  & -Inf         & Inf          \\ \hline
    \end{tabular}
    \caption{Observación del entorno para CartPole}
    \label{obs-cartpole}
\end{table}

Como podemos ver a través de las observaciones, este es uno de esos problemas en los que el número de estados distintos es potencialmente infinito, debido a que estamos tratando con valores continuos. Por ello tendremos que encontrar una buena \textbf{función de discretización} que simplifique la representación del estado y nos permita trabajar con un número óptimo de estados. Por suerte para nosotros, disponer de un número tan limitado de acciones posibles disminuye la complejidad del problema.

\subsection{Discretizando el estado}
A la hora de discretizar una observación, una de las mejores formas de hacerlo es a través de una simplificación de la misma. Este acercamiento es una adaptación del \textit{Constraint Relaxation} que se aplica en muchos problemas de satisfacción de restricciones. De esta forma podemos comprender el problema desde un punto de partida mucho más sencillo, para después pulir la fórmula y tener en cuenta más variables. Además, podemos ir evaluando el rendimiento de nuestro agente a lo largo del camino, y así poder comprobar si las modificaciones que vamos añadiendo realmente mejoran su comportamiento o simplemente añaden ruido.

Centrémonos por un momento en el objetivo más básico del problema: Mantener el mástil en pie. Podemos dividir el problema en dos estados muy simples, uno en el que el mástil está cayendo hacia la derecha y otro en el cae hacia la izquierda, como podemos ver en la Figura \ref{fig:cartpole_01}. Esto coincide con nuestras dos acciones disponibles y, de forma algo ingenua, podemos considerar esto un punto de partida válido.

\figura{Bitmap/Capitulo2/cartpole_01}{width=0.7\textwidth}{fig:cartpole_01}%
       {Simplificación de estados}

Por supuesto, esta discretización es demasiado ingenua para resolver el problema de una forma eficiente; es necesario probar otras divisiones de estados y tener en cuenta las demás observaciones. Para ello creamos una función parametrizable, la cual decide en cuántos estados dividir cada observación. Así podemos decidir a qué observaciones damos más importancia, creando más o menos estados en función a éstas, como podemos apreciar en la Figura \ref{fig:cartpole_02}.

\figura{Bitmap/Capitulo2/cartpole_02}{width=0.7\textwidth}{fig:cartpole_02}%
       {División de las observaciones}

Este aumento en el número de estados permite que nuestro agente sea capaz de especializarse más en acciones concretas. Pero esta mejora viene con un precio a pagar: Cuantos más estados distintos tengamos, más tiempo tardará en visitarlos todos (en repetidas ocasiones) durante su etapa de entrenamiento. Esto quiere decir que nuestro agente tardará más en tener un buen rendimiento. Es importante entonces que evaluemos el problema al que nos enfrentamos para encontrar el equilibrio ideal y así poder ahorrar recursos de memoria y tiempo.

\subsection{Resultados}
\begin{quote}
    CartPole define como solucionado el problema al obtener una recompensa media de 195.0 durante 100 episodios consecutivos.
\end{quote}

Para realizar las mediciones, creamos una cola con una longitud máxima de 100 elementos. En ella añadimos el resultado de cada simulación, de forma que el resultado número 101 elimina el número 1. De esta forma podemos calcular la media sobre la estructura de datos y comprobar si el problema se consideraría resuelto por OpenAI Gym. Además dibujaremos esta media de la estructura tras cada episodio en una gráfica, con el fin de que los resultados sean más fáciles de apreciar y analizar. Las gráficas resultantes tienen variaciones tras cada ejecución, pero el caso más común es el mostrado en la Figura \ref{fig:cartpole_03}.

\figura{Bitmap/Capitulo2/cartpole_03}{width=0.7\textwidth}{fig:cartpole_03}%
       {Visualización de los resultados del agente RL}

En dicha gráfica se pueden apreciar tres etapas distintas en el rendimiento del agente:
\begin{itemize}
    \item Episodios 1-50: durante las primeras simulaciones el agente aún ha de rellenar la tabla-Q. Se encuentra ante situaciones nuevas ante las que aún no sabe como reaccionar. Además hay que tener en cuenta que su rendimiento se calcula en base a la media con los primeros resultados, por lo que en la etapa final de esta fase aún es lastrado por esos primeros episodios.
    \item Episodios 50-300: suponen el despegue en rendimiento del agente. En ellos se empieza a librar del lastre de las primeras simulaciones, además de que su tabla interna ya se encuentra en un estado bastante estable y es capaz de generar mejores resultados.
    \item A partir del episodio 300: el agente alcanza su meta y el algoritmo comienza a estabilizarse.
\end{itemize}

Cabe destacar que estos resultados han sido obtenidos con una configuración en la discretización de \texttt{(1, 1, 3, 6)}. ¿Por qué optamos por esta configuración? Mientras probábamos distintas configuraciones descubrimos que el principal motivo de finalización de una simulación era la caída del mástil. En la mayoría de las ocasiones el mástil cae mucho antes de que el carro alcance los límites laterales. Esto nos permite ignorar las dos primeras observaciones (posición del carro y velocidad del carro) reduciendo notablemente la dimensionalidad del problema.

De esta forma, contamos con un espacio dimensional bastante reducido ($1*1*3*6=18$ estados). Si por el contrario hubiésemos optado por un número mayor de estados, la primera fase descrita arriba se alargaría considerablemente, pero a cambio podríamos esperar una mayor estabilidad del agente en la tercera fase.

\section{Los límites del Aprendizaje por Refuerzo}
A lo largo de este capítulo hemos introducido el \textit{Aprendizaje por Refuerzo} como método de aprendizaje, las ventajas que tiene sobre otros métodos, sus mecánicas y elementos, algunos de sus algoritmos... Pero también hemos dejado entrever ciertos problemas.

El más importante es el que vimos durante la discretización del estado. Este problema es conocido como la \textbf{maldición de la dimensión}(\textit{curse of dimensionality}) y hace referencia al aumento exponencial en el tamaño de las tablas de estados en la memoria de los agentes. El problema puede ser contenido a través de buenas aproximaciones en la discretización; no obstante, un entorno continuo lo bastante complejo acaba resultando inviable de afrontar.

Otra solución ha surgido durante los últimos años y consiste en combinar el \textit{Aprendizaje por Refuerzo} con técnicas de \textit{Deep Learning}, que estudiaremos en los próximos capítulos.
